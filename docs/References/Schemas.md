---
title: Virtualization SDK
---

# Schemas

## About Schemas

Any time a plugin needs to store its own data, or needs to ask the user for data, the Delphix Engine needs to be told about the format of that data:

* What is the set of data needed and what should they be called?
* What is the type of each piece of data: Strings? Integers? Booleans?

Plugins use [schemas](Glossary.md#schema) to describe the format of such data. Once a schema is defined, it is used in three ways

1. It tells the Delphix Engine how to store the data for later use.
2. It is used to autogenerate a custom user interface, and to validate user inputs.
3. It is used to [autogenerate Python classes](Schemas_and_Autogenerated_Classes.md) that can be used by plugin code to access and manipulate user input and stored data.

There are five plugin-customizable data formats:

Delphix Object | Schema | Autogenerated Class
-------------- | ------ | -------------------
[Repository](Glossary.md#repository) | [RepositoryDefinition](Schemas_and_Autogenerated_Classes.md#repositorydefinition-schema) | [RepositoryDefinition](Schemas_and_Autogenerated_Classes.md#repositorydefintion-class)
[Source Config](Glossary.md#source-config) | [SourceConfigDefinition](Schemas_and_Autogenerated_Classes.md#sourceconfigdefinition-schema) | [SourceConfigDefinition](Schemas_and_Autogenerated_Classes.md#sourceconfigdefinition-class)
[Linked Source](Glossary.md#linked-source) | [LinkedSourceDefinition](Schemas_and_Autogenerated_Classes.md#linkedsourcedefinition-schema) | [LinkedSourceDefinition](Schemas_and_Autogenerated_Classes.md#linkedsourcedefinition-class)
[Virtual Source](Glossary.md#virtual-source) | [VirtualSourceDefinition](Schemas_and_Autogenerated_Classes.md#virtualsourcedefinition-schema)| [VirtualSourceDefinition](Schemas_and_Autogenerated_Classes.md#virtualsourcedefinition-class)
[Snapshot](Glossary.md#linked-source) | [SnapshotDefinition](Schemas_and_Autogenerated_Classes.md#snapshotdefinition-schema) | [SnapshotDefinition](Schemas_and_Autogenerated_Classes.md#snapshotdefinition-class)


## JSON Schemas

Plugins use JSON schemas for their custom datatypes. There are three main things to understand about them, which are explained just below:

* What is JSON?
* What is a JSON schema?
* How has Delphix augmented JSON schemas?

### JSON
JSON stands for "Javascript Object Notation". JSON is a data-interchange format that is intended to be precise and also somewhat human-readable. Here are some simple examples of data in JSON format:

JSON | Description
---- | ------------
`"hello"`     | A string. Note the double quotes.
`17`          | An integer
`true`        | A boolean
`{"name": "Julie", "age": 37}` | A JSON object with two fields, `name` (a string), and `age` (an integer). Objects are denoted with curly braces.
`[ true, false, true] ` | A JSON array with three booleans. Arrays are denoted with square brackets.

For more details on JSON, please see https://www.json.org/.

### JSON Schemas

The "JSON schema" format is built on top of JSON. This adds some special rules and keywords that are intended to facilitate the *description* of the format of data (whereas "raw" JSON is intended for storing data).

Here is an example of a JSON schema that defines a (simplified) US address:

```json
{
    "type": "object",
    "required": ["name", "streetNumber", "street", "city", "state", "zip5"],
    "additionalProperties": false,
    "properties": {
        "name": { "type": "string" },
        "streetNumber": { "type": "string" },
        "street": { "type": "string" },
        "unit": { "type": "string" },
        "city": { "type": "string", "pattern": "^[A-Z][A-Za-z ]*$" },
        "state": { "type": "string", "pattern": "^[A-Z]{2}$" },
        "zip5": { "type": "string", "pattern": "^[0-9]{5}"},
        "zipPlus4": { "type": "string", "pattern": "^[0-9]{4}"}
    }
}
```

Note that this is perfectly valid JSON data. It's a JSON object with four fields: `type` (a JSON string), `required` (A JSON array), `additionalProperties` (a JSON boolean), and `properties`. `properties`, in turn is a JSON object with with 8 fields, each of which is a JSON object, with its own properties, etc.

But, this isn't *just* a JSON object. This is a JSON schema. It uses special keywords like `type` `required`, and `additionalProperties`. These have specially-defined meanings in the context of JSON schemas.

Here is a list of the special keywords used by the above schema. Note that this is only a small subset of JSON schema keywords.

keyword | description
------- | -----------
`additionalProperties` | Determines whether the schema allows properties that are not explicitly listed in the `properties` specification. Must be a `true` or `false`.
`pattern` | Used with string types to specify a regular expression that the property must conform to.
`required`| A list of required properties. Properties not listed in this list are optional.
`string`  | Used with `type` to declare that a property must be a string.
`type`    | Specifies a datatype. Common values are `object`, `array`, `number`, `integer`, `boolean`, and `string`.

Some points to note about the address schema above:

* Because of the `required` list, all valid addresses must have fields called `name`, `streetNumber` and so on.
* `unit` and `zipPlus4` do not appear in the `required` list, and therefore are optional.
* Because of `additionalProperties` being `false`, valid addresses cannot make up their own fields like `nickname` or `doorbellLocation`.
* Because of the `pattern`, any `state` field in a valid address must consist of exactly two capital letters.
* Similarly, `city` must only contain letters and spaces, and `zip` and `zipPlus4` must only contain digits.
* Each property has its own valid subschema that describes its own type definition.

Here is a JSON object that conforms to the above schema:

```json
{
  "name": "Delphix",
  "streetNumber": "220",
  "street": "Congress St.",
  "unit": "200",
  "city": "Boston",
  "state": "MA",
  "zip": "02210"
}
```

!!! info
    A common point of confusion is the distinction between a JSON schema and a JSON object that conforms to a schema. Remember, a schema describes the form of data. In our example, the schema *describes* what an address looks like. The address itself is not a schema.


For much more detail on JSON schemas, including which keywords are available, what they mean, and where you can use them, see https://json-schema.org/understanding-json-schema/


### Delphix-specific Extensions to JSON Schema

The JSON schema vocabulary is designed to be extensible for special uses, and Delphix has taken advantage of this to add some new Delphix-specific keywords.

The list below outlines each of these keywords, and provides minimal examples of how they might be used.

#### `description`

| Summary | |
|-------- | |
| Required or Optional? | Optional|
| Where? | In any property subschema, at the same level as `type`.|

The `description` keyword can optionally appear on any property. If it does appear, it is used by the UI as explanatory text for the UI widget associated with the property. If it does not appear, then no explanatory text is shown.

In this example, the UI would show "User-readable name for the provisioned database" in small text under the widget.

```json
{
  "properties": {
    "name": {
      "type": "string",
      "description": "User-readable name for the provisioned database"
    }
  }
}
```

#### `identityFields`

| Summary | |
| ------- | |
| Required or Optional? | Required (for repository and source config schemas only) |
| Where? | At the top level of a repository or source config schema, at the same level as `type` and `properties`.|

The `identityFields` is a list of property names that, together, serve as a unique identifier for a repository or source config.

When a plugin's [automatic discovery](Glossary.md#automatic-discovery) code is called, it will return a list of repositories (or source configs). The Delphix Engine needs to be able to compare this new list with whatever repositories it already knows about.

For example, suppose the engine already knows about a single repository with data `{"dbname": "my_databsae", "path": "/var/db/db01"}` (note the misspelling!). And, then suppose that automatic discovery is re-run and it returns repository data `{ "dbname": "my_database", "path": "/var/db/db01"}`.

What should the Delphix Engine do? Should it conclude that "my_databsae" has been deleted, and there is a completely new repository named "my_database"? Or, should it conclude that we still have the same old repository, but with an updated name?

`identityFields` is used to handle this. When the engine compares "new" data with "old" data, it concludes that they belong to the same repository if **all** of the identity fields match. If any of the identity fields do not match, then the "new" repository data is judged to represent a different repository than the old data.

`identityFields` is **required** for [RepositoryDefinition](Schemas_and_Autogenerated_Classes.md#repositorydefinition-schema) and [SourceConfigDefinition](Schemas_and_Autogenerated_Classes.md#sourceconfigdefinition-schema) schemas, and may not be used in any other schemas.

In this example, we'll tell the Delphix Engine that `path` is the sole unique identifier.

```json
{
  "properties": {
      "dbname": {"type": "string"},
      "path": {"type": "string"}
  },
  "identityFields": ["path"]
}
```

#### `nameField`

| Summary | |
| ------- | |
| Required or Optional? | Required (for repository and source config schemas only) |
| Where? | At the top level of a repository or source config schema, at the same level as `type` and `properties`.|

The `nameField` keyword specifies a single property that is to be used to name the object in the Delphix Engine. The property must be a string field. This keyword is used at the same level as `properties`. It is **required** for [RepositoryDefinition](Schemas_and_Autogenerated_Classes.md#repositorydefinition-schema) and [SourceConfigDefinition](Schemas_and_Autogenerated_Classes.md#sourceconfigdefinition-schema) schemas, and may not be used in any other schemas.

In this example, we will use the `path` property as the user-visible name.

```json
{
    "properties": {
        "path": { "type": "string" },
        "port": { "type": "integer" }
    },
    "nameField": "path"
}
```

So, if we have an repository object that looks like

```json
{
  "path": "/usr/bin",
  "port": 8800
}
```
then the user will be able to refer to this object as `/usr/bin`.


#### `password`

| Summary | |
| ------- | |
| Required or Optional? | Optional|
| Where? | As the value for the `format` keyword in any string property's subschema.|

The `password` keyword can be used to specify the `format` of a `string`. (Note that `format` is a standard keyword and is not Delphix-specific). If a property is tagged as a password, then the UI will never show the value on screen, and the value will be encrypted before being stored as described [here](/Best_Practices/Sensitive_Data.md).

In this example, the `dbPass` field on any object will be treated as a password.

```json
{
  "properties": {
    "dbPass": {
      "type": "string",
      "format": "password"
    }
  }
}
```

#### `prettyName`

| Summary | |
| ------- | |
| Required or Optional? | Optional|
| Where? | In any property subschema, at the same level as `type`.|

The `prettyName` keyword can optionally appear on any property. If it does appear, it is used by the UI as a title for the UI widget associated with the property. If it does not appear, then the name of the property is used.

In this example, the user would see "Name of Database" on the UI, instead of just "name".

```json
{
  "properties": {
    "name": {
      "type": "string",
      "prettyName": "Name of Database"
    }
  }
}
```

#### `unixpath`

| Summary | |
| ------- | |
| Required or Optional? | Optional|
| Where? | As the value for the `format` keyword in any string property's subschema.|

The `unixpath` keyword is used to specify the format of a string. This will allow the Delphix Engine to verify and enforce that a particular field can be parsed as a valid Unix path.

```json
{
  "properties": {
    "datapath": {
      "type": "string",
      "format": "unixpath"
    }
  }
}
```
