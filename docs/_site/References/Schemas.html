<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Virtualization SDK | virtualization-sdk</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Virtualization SDK" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/References/Schemas.html" />
<meta property="og:url" content="http://localhost:4000/References/Schemas.html" />
<meta property="og:site_name" content="virtualization-sdk" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/References/Schemas.html","headline":"Virtualization SDK","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=52f3c2ef1003e9fe35bc8813a5d4baa843da74c1">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">virtualization-sdk</a></h1>
      

      <h1 id="schemas">Schemas</h1>

<h2 id="about-schemas">About Schemas</h2>

<p>Any time a plugin needs to store its own data, or needs to ask the user for data, the Delphix Engine needs to be told about the format of that data:</p>

<ul>
  <li>What is the set of data needed and what should they be called?</li>
  <li>What is the type of each piece of data: Strings? Integers? Booleans?</li>
</ul>

<p>Plugins use <a href="/References/Glossary.html#schema">schemas</a> to describe the format of such data. Once a schema is defined, it is used in three ways</p>

<ol>
  <li>It tells the Delphix Engine how to store the data for later use.</li>
  <li>It is used to autogenerate a custom user interface, and to validate user inputs.</li>
  <li>It is used to <a href="/References/Schemas_and_Autogenerated_Classes.html">autogenerate Python classes</a> that can be used by plugin code to access and manipulate user input and stored data.</li>
</ol>

<p>There are five plugin-customizable data formats:</p>

<table>
  <thead>
    <tr>
      <th>Delphix Object</th>
      <th>Schema</th>
      <th>Autogenerated Class</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="/References/Glossary.html#repository">Repository</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#repositorydefinition-schema">RepositoryDefinition</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#repositorydefintion-class">RepositoryDefinition</a></td>
    </tr>
    <tr>
      <td><a href="/References/Glossary.html#source-config">Source Config</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#sourceconfigdefinition-schema">SourceConfigDefinition</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#sourceconfigdefinition-class">SourceConfigDefinition</a></td>
    </tr>
    <tr>
      <td><a href="/References/Glossary.html#linked-source">Linked Source</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#linkedsourcedefinition-schema">LinkedSourceDefinition</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#linkedsourcedefinition-class">LinkedSourceDefinition</a></td>
    </tr>
    <tr>
      <td><a href="/References/Glossary.html#virtual-source">Virtual Source</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#virtualsourcedefinition-schema">VirtualSourceDefinition</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#virtualsourcedefinition-class">VirtualSourceDefinition</a></td>
    </tr>
    <tr>
      <td><a href="/References/Glossary.html#linked-source">Snapshot</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#snapshotdefinition-schema">SnapshotDefinition</a></td>
      <td><a href="/References/Schemas_and_Autogenerated_Classes.html#snapshotdefinition-class">SnapshotDefinition</a></td>
    </tr>
  </tbody>
</table>

<h2 id="json-schemas">JSON Schemas</h2>

<p>Plugins use JSON schemas for their custom datatypes. There are three main things to understand about them, which are explained just below:</p>

<ul>
  <li>What is JSON?</li>
  <li>What is a JSON schema?</li>
  <li>How has Delphix augmented JSON schemas?</li>
</ul>

<h3 id="json">JSON</h3>
<p>JSON stands for “Javascript Object Notation”. JSON is a data-interchange format that is intended to be precise and also somewhat human-readable. Here are some simple examples of data in JSON format:</p>

<table>
  <thead>
    <tr>
      <th>JSON</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">"hello"</code></td>
      <td>A string. Note the double quotes.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">17</code></td>
      <td>An integer</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">true</code></td>
      <td>A boolean</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">{"name": "Julie", "age": 37}</code></td>
      <td>A JSON object with two fields, <code class="highlighter-rouge">name</code> (a string), and <code class="highlighter-rouge">age</code> (an integer). Objects are denoted with curly braces.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">[ true, false, true] </code></td>
      <td>A JSON array with three booleans. Arrays are denoted with square brackets.</td>
    </tr>
  </tbody>
</table>

<p>For more details on JSON, please see https://www.json.org/.</p>

<h3 id="json-schemas-1">JSON Schemas</h3>

<p>The “JSON schema” format is built on top of JSON. This adds some special rules and keywords that are intended to facilitate the <em>description</em> of the format of data (whereas “raw” JSON is intended for storing data).</p>

<p>Here is an example of a JSON schema that defines a (simplified) US address:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"object"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"required"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"name"</span><span class="p">,</span><span class="w"> </span><span class="s2">"streetNumber"</span><span class="p">,</span><span class="w"> </span><span class="s2">"street"</span><span class="p">,</span><span class="w"> </span><span class="s2">"city"</span><span class="p">,</span><span class="w"> </span><span class="s2">"state"</span><span class="p">,</span><span class="w"> </span><span class="s2">"zip5"</span><span class="p">],</span><span class="w">
    </span><span class="s2">"additionalProperties"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="s2">"streetNumber"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="s2">"street"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="s2">"unit"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="s2">"city"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pattern"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^[A-Z][A-Za-z ]*$"</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="s2">"state"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pattern"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^[A-Z]{2}$"</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="s2">"zip5"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pattern"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^[0-9]{5}"</span><span class="p">},</span><span class="w">
        </span><span class="s2">"zipPlus4"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w"> </span><span class="s2">"pattern"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^[0-9]{4}"</span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Note that this is perfectly valid JSON data. It’s a JSON object with four fields: <code class="highlighter-rouge">type</code> (a JSON string), <code class="highlighter-rouge">required</code> (A JSON array), <code class="highlighter-rouge">additionalProperties</code> (a JSON boolean), and <code class="highlighter-rouge">properties</code>. <code class="highlighter-rouge">properties</code>, in turn is a JSON object with with 8 fields, each of which is a JSON object, with its own properties, etc.</p>

<p>But, this isn’t <em>just</em> a JSON object. This is a JSON schema. It uses special keywords like <code class="highlighter-rouge">type</code> <code class="highlighter-rouge">required</code>, and <code class="highlighter-rouge">additionalProperties</code>. These have specially-defined meanings in the context of JSON schemas.</p>

<p>Here is a list of the special keywords used by the above schema. Note that this is only a small subset of JSON schema keywords.</p>

<table>
  <thead>
    <tr>
      <th>keyword</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">additionalProperties</code></td>
      <td>Determines whether the schema allows properties that are not explicitly listed in the <code class="highlighter-rouge">properties</code> specification. Must be a <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code>.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">pattern</code></td>
      <td>Used with string types to specify a regular expression that the property must conform to.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">required</code></td>
      <td>A list of required properties. Properties not listed in this list are optional.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">string</code></td>
      <td>Used with <code class="highlighter-rouge">type</code> to declare that a property must be a string.</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">type</code></td>
      <td>Specifies a datatype. Common values are <code class="highlighter-rouge">object</code>, <code class="highlighter-rouge">array</code>, <code class="highlighter-rouge">number</code>, <code class="highlighter-rouge">integer</code>, <code class="highlighter-rouge">boolean</code>, and <code class="highlighter-rouge">string</code>.</td>
    </tr>
  </tbody>
</table>

<p>Some points to note about the address schema above:</p>

<ul>
  <li>Because of the <code class="highlighter-rouge">required</code> list, all valid addresses must have fields called <code class="highlighter-rouge">name</code>, <code class="highlighter-rouge">streetNumber</code> and so on.</li>
  <li><code class="highlighter-rouge">unit</code> and <code class="highlighter-rouge">zipPlus4</code> do not appear in the <code class="highlighter-rouge">required</code> list, and therefore are optional.</li>
  <li>Because of <code class="highlighter-rouge">additionalProperties</code> being <code class="highlighter-rouge">false</code>, valid addresses cannot make up their own fields like <code class="highlighter-rouge">nickname</code> or <code class="highlighter-rouge">doorbellLocation</code>.</li>
  <li>Because of the <code class="highlighter-rouge">pattern</code>, any <code class="highlighter-rouge">state</code> field in a valid address must consist of exactly two capital letters.</li>
  <li>Similarly, <code class="highlighter-rouge">city</code> must only contain letters and spaces, and <code class="highlighter-rouge">zip</code> and <code class="highlighter-rouge">zipPlus4</code> must only contain digits.</li>
  <li>Each property has its own valid subschema that describes its own type definition.</li>
</ul>

<p>Here is a JSON object that conforms to the above schema:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Delphix"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"streetNumber"</span><span class="p">:</span><span class="w"> </span><span class="s2">"220"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"street"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Congress St."</span><span class="p">,</span><span class="w">
  </span><span class="s2">"unit"</span><span class="p">:</span><span class="w"> </span><span class="s2">"200"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"city"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Boston"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"state"</span><span class="p">:</span><span class="w"> </span><span class="s2">"MA"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"zip"</span><span class="p">:</span><span class="w"> </span><span class="s2">"02210"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>!!! info
    A common point of confusion is the distinction between a JSON schema and a JSON object that conforms to a schema. Remember, a schema describes the form of data. In our example, the schema <em>describes</em> what an address looks like. The address itself is not a schema.</p>

<p>For much more detail on JSON schemas, including which keywords are available, what they mean, and where you can use them, see https://json-schema.org/understanding-json-schema/</p>

<h3 id="delphix-specific-extensions-to-json-schema">Delphix-specific Extensions to JSON Schema</h3>

<p>The JSON schema vocabulary is designed to be extensible for special uses, and Delphix has taken advantage of this to add some new Delphix-specific keywords.</p>

<p>The list below outlines each of these keywords, and provides minimal examples of how they might be used.</p>

<h4 id="description"><code class="highlighter-rouge">description</code></h4>

<table>
  <thead>
    <tr>
      <th>Summary</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Required or Optional?</td>
      <td>Optional</td>
    </tr>
    <tr>
      <td>Where?</td>
      <td>In any property subschema, at the same level as <code class="highlighter-rouge">type</code>.</td>
    </tr>
  </tbody>
</table>

<p>The <code class="highlighter-rouge">description</code> keyword can optionally appear on any property. If it does appear, it is used by the UI as explanatory text for the UI widget associated with the property. If it does not appear, then no explanatory text is shown.</p>

<p>In this example, the UI would show “User-readable name for the provisioned database” in small text under the widget.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
      </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"User-readable name for the provisioned database"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="identityfields"><code class="highlighter-rouge">identityFields</code></h4>

<table>
  <thead>
    <tr>
      <th>Summary</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Required or Optional?</td>
      <td>Required (for repository and source config schemas only)</td>
    </tr>
    <tr>
      <td>Where?</td>
      <td>At the top level of a repository or source config schema, at the same level as <code class="highlighter-rouge">type</code> and <code class="highlighter-rouge">properties</code>.</td>
    </tr>
  </tbody>
</table>

<p>The <code class="highlighter-rouge">identityFields</code> is a list of property names that, together, serve as a unique identifier for a repository or source config.</p>

<p>When a plugin’s <a href="/References/Glossary.html#automatic-discovery">automatic discovery</a> code is called, it will return a list of repositories (or source configs). The Delphix Engine needs to be able to compare this new list with whatever repositories it already knows about.</p>

<p>For example, suppose the engine already knows about a single repository with data <code class="highlighter-rouge">{"dbname": "my_databsae", "path": "/var/db/db01"}</code> (note the misspelling!). And, then suppose that automatic discovery is re-run and it returns repository data <code class="highlighter-rouge">{ "dbname": "my_database", "path": "/var/db/db01"}</code>.</p>

<p>What should the Delphix Engine do? Should it conclude that “my_databsae” has been deleted, and there is a completely new repository named “my_database”? Or, should it conclude that we still have the same old repository, but with an updated name?</p>

<p><code class="highlighter-rouge">identityFields</code> is used to handle this. When the engine compares “new” data with “old” data, it concludes that they belong to the same repository if <strong>all</strong> of the identity fields match. If any of the identity fields do not match, then the “new” repository data is judged to represent a different repository than the old data.</p>

<p><code class="highlighter-rouge">identityFields</code> is <strong>required</strong> for <a href="/References/Schemas_and_Autogenerated_Classes.html#repositorydefinition-schema">RepositoryDefinition</a> and <a href="/References/Schemas_and_Autogenerated_Classes.html#sourceconfigdefinition-schema">SourceConfigDefinition</a> schemas, and may not be used in any other schemas.</p>

<p>In this example, we’ll tell the Delphix Engine that <code class="highlighter-rouge">path</code> is the sole unique identifier.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="s2">"dbname"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">},</span><span class="w">
      </span><span class="s2">"path"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="s2">"identityFields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"path"</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="namefield"><code class="highlighter-rouge">nameField</code></h4>

<table>
  <thead>
    <tr>
      <th>Summary</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Required or Optional?</td>
      <td>Required (for repository and source config schemas only)</td>
    </tr>
    <tr>
      <td>Where?</td>
      <td>At the top level of a repository or source config schema, at the same level as <code class="highlighter-rouge">type</code> and <code class="highlighter-rouge">properties</code>.</td>
    </tr>
  </tbody>
</table>

<p>The <code class="highlighter-rouge">nameField</code> keyword specifies a single property that is to be used to name the object in the Delphix Engine. The property must be a string field. This keyword is used at the same level as <code class="highlighter-rouge">properties</code>. It is <strong>required</strong> for <a href="/References/Schemas_and_Autogenerated_Classes.html#repositorydefinition-schema">RepositoryDefinition</a> and <a href="/References/Schemas_and_Autogenerated_Classes.html#sourceconfigdefinition-schema">SourceConfigDefinition</a> schemas, and may not be used in any other schemas.</p>

<p>In this example, we will use the <code class="highlighter-rouge">path</code> property as the user-visible name.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"path"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="w"> </span><span class="p">},</span><span class="w">
        </span><span class="s2">"port"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"integer"</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="s2">"nameField"</span><span class="p">:</span><span class="w"> </span><span class="s2">"path"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>So, if we have an repository object that looks like</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"path"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/usr/bin"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"port"</span><span class="p">:</span><span class="w"> </span><span class="mi">8800</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>then the user will be able to refer to this object as <code class="highlighter-rouge">/usr/bin</code>.</p>

<h4 id="password"><code class="highlighter-rouge">password</code></h4>

<table>
  <thead>
    <tr>
      <th>Summary</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Required or Optional?</td>
      <td>Optional</td>
    </tr>
    <tr>
      <td>Where?</td>
      <td>As the value for the <code class="highlighter-rouge">format</code> keyword in any string property’s subschema.</td>
    </tr>
  </tbody>
</table>

<p>The <code class="highlighter-rouge">password</code> keyword can be used to specify the <code class="highlighter-rouge">format</code> of a <code class="highlighter-rouge">string</code>. (Note that <code class="highlighter-rouge">format</code> is a standard keyword and is not Delphix-specific). If a property is tagged as a password, then the UI will never show the value on screen, and the value will be encrypted before being stored as described <a href="/Best_Practices/Sensitive_Data.md">here</a>.</p>

<p>In this example, the <code class="highlighter-rouge">dbPass</code> field on any object will be treated as a password.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"dbPass"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
      </span><span class="s2">"format"</span><span class="p">:</span><span class="w"> </span><span class="s2">"password"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="prettyname"><code class="highlighter-rouge">prettyName</code></h4>

<table>
  <thead>
    <tr>
      <th>Summary</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Required or Optional?</td>
      <td>Optional</td>
    </tr>
    <tr>
      <td>Where?</td>
      <td>In any property subschema, at the same level as <code class="highlighter-rouge">type</code>.</td>
    </tr>
  </tbody>
</table>

<p>The <code class="highlighter-rouge">prettyName</code> keyword can optionally appear on any property. If it does appear, it is used by the UI as a title for the UI widget associated with the property. If it does not appear, then the name of the property is used.</p>

<p>In this example, the user would see “Name of Database” on the UI, instead of just “name”.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
      </span><span class="s2">"prettyName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Name of Database"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="unixpath"><code class="highlighter-rouge">unixpath</code></h4>

<table>
  <thead>
    <tr>
      <th>Summary</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Required or Optional?</td>
      <td>Optional</td>
    </tr>
    <tr>
      <td>Where?</td>
      <td>As the value for the <code class="highlighter-rouge">format</code> keyword in any string property’s subschema.</td>
    </tr>
  </tbody>
</table>

<p>The <code class="highlighter-rouge">unixpath</code> keyword is used to specify the format of a string. This will allow the Delphix Engine to verify and enforce that a particular field can be parsed as a valid Unix path.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"datapath"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
      </span><span class="s2">"format"</span><span class="p">:</span><span class="w"> </span><span class="s2">"unixpath"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
