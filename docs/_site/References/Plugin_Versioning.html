<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Plugin Versioning | virtualization-sdk</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Plugin Versioning" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/References/Plugin_Versioning.html" />
<meta property="og:url" content="http://localhost:4000/References/Plugin_Versioning.html" />
<meta property="og:site_name" content="virtualization-sdk" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/References/Plugin_Versioning.html","headline":"Plugin Versioning","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=52f3c2ef1003e9fe35bc8813a5d4baa843da74c1">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">virtualization-sdk</a></h1>
      

      <h1 id="plugin-versioning">Plugin Versioning</h1>

<p>Like any other piece of software, a plugin will change over time. New features will be added, bugs will be fixed, and so on.</p>

<p>To keep track of this, plugins must specify a version string. There are rules about what sorts of plugin changes go along with changes to the version string. Before we get into the rules, let’s talk about a problem that we want to avoid.</p>

<h2 id="problems-with-data-format-mismatches">Problems With Data Format Mismatches</h2>

<p>Plugins supply <a href="/References/Glossary.html#schema">schemas</a> to define their own datatypes. Data that conforms to these schemas is saved by the Delphix Engine. Later, the Delphix Engine may read back that saved data, and provide it to plugin code.</p>

<p>Imagine this sequence of events:</p>

<ol>
  <li>A plugin is initially released. In its snapshot schema, it defines two properties, <code class="highlighter-rouge">date</code> and <code class="highlighter-rouge">time</code>, that together specify when the snapshot was taken.</li>
  <li>A user installs the initial release of the plugin on their Delphix Engine.</li>
  <li>The user takes a snapshot of a <a href="/References/Glossary.html#dsource">dSource</a>. Along with this snapshot is stored the <code class="highlighter-rouge">date</code> and <code class="highlighter-rouge">time</code>.</li>
  <li>A new version of the same plugin is released. In this new version, the snapshot schema now only defines a single property called <code class="highlighter-rouge">timestamp</code>, which specified both the date and the time together in a single property.</li>
  <li>The user installs the new plugin version.</li>
  <li>The user attempts to <a href="/References/Glossary.html#provisioning">provision</a> a new <a href="/References/Glossary.html#vdb">VDB</a> from the snapshot they took in step 3.</li>
</ol>

<p>Now, when provision-related plugin code is called (for example the <a href="/References/Plugin_Operations.html#virtual-source-configure">configure</a> operation), it is going to be handed the snapshot data that was stored in step 2.</p>

<p>The problem here is that we’ll have a data format mismatch. The previously-saved snapshot data will have separate <code class="highlighter-rouge">date</code> and <code class="highlighter-rouge">time</code> fields, but the new plugin code will be expecting instead a single field called <code class="highlighter-rouge">timestamp</code>.</p>

<h2 id="data-upgrading">Data Upgrading</h2>

<p><strong>Coming Soon!</strong></p>

<h2 id="versioning-rules">Versioning Rules</h2>

<p>Each plugin declares a version string in the format <code class="highlighter-rouge">&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code>. The <code class="highlighter-rouge">major</code> and <code class="highlighter-rouge">minor</code> parts must always be integers, but <code class="highlighter-rouge">patch</code> can be any alphanumeric string.</p>

<p>There are two scenarios where one version of a plugin can be installed on an engine that already has another version of the same plugin installed.</p>

<h3 id="patch-only-changes">Patch-only Changes</h3>

<p>If only the <code class="highlighter-rouge">patch</code> part of the version is changing, there are a relaxed set of rules:</p>

<ul>
  <li>Schemas <strong>may not</strong> change.</li>
  <li>There is no defined ordering for patches. So long as <code class="highlighter-rouge">major</code> and <code class="highlighter-rouge">minor</code> do not change, any patch level can replace any other patch level.</li>
</ul>

<h3 id="majorminor-changes">Major/Minor Changes</h3>

<p>If either <code class="highlighter-rouge">major</code> or <code class="highlighter-rouge">minor</code> (or both) is changing, then the following rules are applied:</p>

<ul>
  <li>The major/minor pair <strong>may not</strong> decrease. If you have version <code class="highlighter-rouge">1.2.x</code> already installed, then for example you can install <code class="highlighter-rouge">1.3.y</code> or <code class="highlighter-rouge">2.0.y</code>. But, you are not allowed to “downgrade” to version <code class="highlighter-rouge">1.1.z</code>.</li>
  <li>Schemas <strong>may</strong> change.</li>
  <li>The plugin <strong>must</strong> provide upgrade operations so that old-format data can be converted as necessary.</li>
</ul>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
