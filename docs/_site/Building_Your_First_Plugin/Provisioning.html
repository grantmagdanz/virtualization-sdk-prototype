<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Virtualization SDK | virtualization-sdk</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Virtualization SDK" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/Building_Your_First_Plugin/Provisioning.html" />
<meta property="og:url" content="http://localhost:4000/Building_Your_First_Plugin/Provisioning.html" />
<meta property="og:site_name" content="virtualization-sdk" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/Building_Your_First_Plugin/Provisioning.html","headline":"Virtualization SDK","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=52f3c2ef1003e9fe35bc8813a5d4baa843da74c1">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">virtualization-sdk</a></h1>
      

      <h1 id="provisioning">Provisioning</h1>

<h2 id="what-is-provisioning">What is Provisioning?</h2>
<p>Once Delphix has a <a href="/References/Glossary.md#snapshot">snapshot</a> of a dataset (for example of a dSource), it is possible to quickly clone that snapshot to create a new <a href="/References/Glossary.md#virtual-dataset">virtual dataset</a>. This new virtual dataset will be made available for use on a <a href="/References/Glossary.md#target-environment">target environment</a>. This process is called <a href="/References/Glossary.md#provisioning">provisioning</a>.</p>

<h2 id="our-provisioning-strategy">Our Provisioning Strategy</h2>
<p>For many plugins, there is a lot of work that needs to be done before a newly-provisioned virtual dataset can be made useful. For example, it might need to be registered with a running DBMS. Or, maybe some data inside the dataset needs to be changed so it behaves properly on the target environment.</p>

<p>In our case, however, there is very little to do. All we really require is that the files in the virtual dataset are accessible at some path on the target environment. Since the Delphix Engine takes care of mounting the data, we only need to worry about controlling <em>where</em> that data is mounted.</p>

<h2 id="defining-our-provision-related-data-formats">Defining our Provision-Related Data Formats</h2>

<p>We have already seen four custom data formats: for repositories, source configs, snapshots and
linked sources. The final one is used for <a href="/References/Glossary.md#virtual-source">virtual sources</a>.</p>

<p>Recall that, for our plugin, a VDB is just a directory full of files. There is no special
procedure needed to enable it, no DBMS to coordinate with, etc. All we need to do is make the files
available on the target environment.</p>

<p>So, the only question for the user is “Where should these files live?”</p>

<p>Open up <code class="highlighter-rouge">schema.json</code>, locate the <code class="highlighter-rouge">virtualSourceDefintion</code> section, and change it to look like this:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"virtualSourceDefinition"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"object"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"additionalProperties"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="s2">"required"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"mountLocation"</span><span class="p">],</span><span class="w">
    </span><span class="s2">"properties"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"mountLocation"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"format"</span><span class="p">:</span><span class="w"> </span><span class="s2">"unixpath"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"prettyName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Mount Location on Target Host"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Where to mount VDB onto the target host"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">},</span><span class="w">
</span></code></pre></div></div>

<p>This should look familiar from the source config schema that we did earlier. We only have one
property, and it represents the mount location on the target environment.</p>

<h2 id="implementing-provisioning">Implementing Provisioning</h2>

<p>There are numerous ways for a plugin to customize the provisioning process.
For our example plugin, we just need to do a few things:</p>

<ol>
  <li>Tell Delphix where to mount the virtual dataset.</li>
  <li>Create a <code class="highlighter-rouge">sourceConfig</code> to represent each newly-provisioned virtual dataset.</li>
  <li>Modify an existing <code class="highlighter-rouge">sourceConfig</code>, if necessary, when the virtual dataset is refreshed or rewound.</li>
  <li>Construct snapshot-related data any time a snapshot is taken of the virtual dataset.</li>
</ol>

<h3 id="controlling-mounting">Controlling Mounting</h3>

<p>As we saw previously with linked sources, we need to tell Delphix where to mount the dataset. Open
up <code class="highlighter-rouge">plugin_runner.py</code> and find the <code class="highlighter-rouge">plugin.virtual.mount_specification</code> decorator. Change that function so that
it looks like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@plugin.virtual.mount_specification</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">vdb_mount_spec</span><span class="p">(</span><span class="n">virtual_source</span><span class="p">,</span> <span class="n">repository</span><span class="p">):</span>
    <span class="n">mount_location</span> <span class="o">=</span> <span class="n">virtual_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mount_location</span>
    <span class="n">mount</span> <span class="o">=</span> <span class="n">Mount</span><span class="p">(</span><span class="n">virtual_source</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">environment</span><span class="p">,</span> <span class="n">mount_location</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MountSpecification</span><span class="p">([</span><span class="n">mount</span><span class="p">])</span>
</code></pre></div></div>

<p>As we did with linked sources, we just look up what the user told us, and then package that up
and return it to Delphix.</p>

<h3 id="creating-a-source-config-for-a-new-vdb">Creating a Source Config for a new VDB</h3>

<p>Just like we saw earlier with <a href="/References/Glossary.md#linked-dataset">linked datasets</a>, each virtual dataset will need its own source config so that the Delphix Engine can interact with it. Our plugin is in charge of creating that source config at provision time</p>

<p>As a reminder, here is what our schema looks like for source configs:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"sourceConfigDefinition"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"object"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"required"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"name"</span><span class="p">,</span><span class="w"> </span><span class="s2">"path"</span><span class="p">],</span><span class="w">
    </span><span class="s2">"additionalProperties"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"prettyName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Dataset Name"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"User-visible name for this dataset"</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="s2">"path"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"format"</span><span class="p">:</span><span class="w"> </span><span class="s2">"unixpath"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"prettyName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Path"</span><span class="p">,</span><span class="w">
          </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Full path to data location on the remote environment"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="s2">"nameField"</span><span class="p">:</span><span class="w"> </span><span class="s2">"name"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"identityFields"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"path"</span><span class="p">]</span><span class="w">
</span><span class="p">},</span><span class="w">
</span></code></pre></div></div>

<p>Thus, for each newly-cloned virtual dataset, we create a new source config object with a name and a
path. This is done by the <code class="highlighter-rouge">configure</code> plugin operation.</p>

<p>In addition to generating a new source config, the configure operation is also tasked with getting
the newly-cloned dataset ready for use on the target environment. What this means exactly will vary
from plugin to plugin. For our simple plugin, the dataset does not require any setup work, and so we
only have to worry about the source config.</p>

<p>Find the <code class="highlighter-rouge">plugin.virtual.configure</code> decorator and change the function to look like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@plugin.virtual.configure</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">configure_new_vdb</span><span class="p">(</span><span class="n">virtual_source</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">,</span> <span class="n">repository</span><span class="p">):</span>
    <span class="n">mount_location</span> <span class="o">=</span> <span class="n">virtual_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">mount_location</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"VDB mounted at {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mount_location</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SourceConfigDefinition</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">mount_location</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="modifying-a-source-config-after-rewind-or-refresh">Modifying a Source Config after Rewind or Refresh</h3>

<p>Just as a new VDB might need to be configured, a refreshed or rewound VDB might need to be
“reconfigured” to handle the new post-refresh (or post-rewind) state of the VDB. So, just as there
is a <code class="highlighter-rouge">configure</code> operation, there is also a <code class="highlighter-rouge">reconfigure</code> operation.</p>

<p>The main difference between the two is that <code class="highlighter-rouge">configure</code> must <em>create</em> a source config, but
<code class="highlighter-rouge">reconfigure</code> needs to <em>modify</em> a pre-existing source config.</p>

<p>In our simple plugin, there is no special work to do at reconfigure time, and there is no reason
to modify anything about the source config. We just need to write a <code class="highlighter-rouge">reconfigure</code> operation that
returns the existing source config without making any changes. Find the <code class="highlighter-rouge">plugin.virtual.reconfigure</code> decorator and modify the function as follows.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@plugin.virtual.reconfigure</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">reconfigure_existing_vdb</span><span class="p">(</span><span class="n">virtual_source</span><span class="p">,</span> <span class="n">repository</span><span class="p">,</span> <span class="n">source_config</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">source_config</span>
</code></pre></div></div>

<h3 id="saving-snapshot-data">Saving Snapshot Data</h3>

<p>As with our linked sources, we don’t actually have anything we need to save when VDB snapshots are
taken. And, again, <code class="highlighter-rouge">dvp init</code> has created a post-snapshot operation that will work just fine for us without modification:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@plugin.virtual.post_snapshot</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">virtual_post_snapshot</span><span class="p">(</span><span class="n">virtual_source</span><span class="p">,</span> <span class="n">repository</span><span class="p">,</span> <span class="n">source_config</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">SnapshotDefinition</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="how-to-provision-in-the-delphix-engine">How To Provision in the Delphix Engine</h2>

<p>Finally, let us try it out to make sure provisioning works!</p>

<ol>
  <li>Again, use <code class="highlighter-rouge">dvp build</code> and <code class="highlighter-rouge">dvp upload</code> to get your new changes onto your Delphix Engine.</li>
  <li>Click <strong>Manage &gt; Datasets</strong>.</li>
  <li>Select the dSource you created in the last page. You should see at least one snapshot, and maybe more than one if you have manually taken a snapshot, or if you have a snapshot policy in place. Select one of these snapshots and click the <strong>Provision vFiles</strong> icon.</li>
  <li>This will open the Provision VDB wizard. Complete the steps and select <strong>Submit</strong>.
  During VDB provisioning one of the things you will have to do is to provide the data required by your virtual source schema. In our case, that means you will be asked to provide a value for <code class="highlighter-rouge">mountLocation</code>. You will also be asked to choose a target environment on which the new VDB will live. After the wizard finishes, you will see a job appear in the <strong>Actions</strong> tab on the right-hand side of the screen. When that job completes, your new VDB should be ready.</li>
  <li>To ensure everything has worked correctly, log into to your target environment. From there, you can examine the directory you specified as the <code class="highlighter-rouge">mountLocation</code>. What you should see is a copy of the directory that you linked to with your dSource.</li>
</ol>

<p>!!! question “<a href="https://forms.gle/zTot9R9sx9PcMwmz5">Survey</a>”
    Please fill out this <a href="https://forms.gle/zTot9R9sx9PcMwmz5">survey</a> to give us feedback about this section.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
