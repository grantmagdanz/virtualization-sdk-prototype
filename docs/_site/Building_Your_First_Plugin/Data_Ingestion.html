<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Virtualization SDK | virtualization-sdk</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Virtualization SDK" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/Building_Your_First_Plugin/Data_Ingestion.html" />
<meta property="og:url" content="http://localhost:4000/Building_Your_First_Plugin/Data_Ingestion.html" />
<meta property="og:site_name" content="virtualization-sdk" />
<script type="application/ld+json">
{"@type":"WebPage","url":"http://localhost:4000/Building_Your_First_Plugin/Data_Ingestion.html","headline":"Virtualization SDK","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=52f3c2ef1003e9fe35bc8813a5d4baa843da74c1">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">
      
      <h1><a href="http://localhost:4000/">virtualization-sdk</a></h1>
      

      <h1 id="data-ingestion">Data Ingestion</h1>

<h2 id="how-does-delphix-ingest-data">How Does Delphix Ingest Data?</h2>

<p>As <a href="/Building_Your_First_Plugin/Discovery.html">previously</a> discussed, the Delphix Engine uses the <a href="/References/Glossary.md#discovery">discovery</a> process to learn about datasets that live on a <a href="/References/Glossary.md#source-environment">source environment</a>. In this section we will learn how the Delphix Engine uses a two-step process to ingest a dataset.</p>

<h3 id="linking">Linking</h3>

<p>The first step is called <a href="/References/Glossary.md#linking">linking</a>. This is simply the creation of a new dataset on the Delphix Engine, which is associated with the dataset on the source environment. This new linked dataset is called a <a href="/References/Glossary.md#dsource">dSource</a>.</p>

<h3 id="syncing">Syncing</h3>

<p>Immediately after linking, the new dSource is <a href="/References/Glossary.md#syncing">synced</a> for the first time. Syncing is a process by which data from the source environment is copied onto the Delphix Engine. Subsequent syncs may then be periodically performed in order to keep the dSource up-to-date.</p>

<p>The details of how this is done varies significantly from plugin to plugin. For example, some plugins will simply copy files from the filesystem. Other plugins might contact a DBMS and instruct it to send backup or replication streams. There are many possibilities here, but they all break down into two main strategies that the plugin author can choose from: direct and staging.</p>

<p>With the <a href="/References/Glossary.md#direct-linkingsyncing">direct</a> strategy, the plugin is not in charge
of the data copying. Instead the Delphix Engine directly pulls raw data from the source environment.
The plugin merely provides the location of the data. This is a very simple strategy, and is also
quite limiting.</p>

<p>For our first plugin, we will be using the more flexible <a href="/References/Glossary.md#staged-linkingsyncing">staging</a> strategy. With this strategy, the Delphix Engine uses NFS for Unix environments (or iSCSI on Windows environments) to mount storage onto a <a href="/References/Glossary.md#staging-environment">staging environment</a>. Our plugin will then be in full control of how to get data from the source environment onto this storage mount.</p>

<p>With the staging strategy, there are two types of syncs: sync and resync. A <code class="highlighter-rouge">sync</code> is used to ingestion incremental changes while a <code class="highlighter-rouge">resync</code> is used to re-ingest all the data for the dSource. For databases, this could mean re-ingesting from a full database backup to reset the dSource. A <code class="highlighter-rouge">sync</code> and a <code class="highlighter-rouge">resync</code> execute the same plugin operations and are differentiated by a boolean flag in the <a href="/References/Classes.md#snapshotparametersdefinition">snapshot_parameters</a> argument passed into <a href="/References/Plugin_Operations.md#staged-linked-source-pre-snapshot">linked.pre_snapshot</a> and <a href="/References/Plugin_Operations.md#staged-linked-source-post-snapshot">linked.post_snapshot</a>.</p>

<p>A regular <code class="highlighter-rouge">sync</code> is the default and is executed as part of policy driven syncs. A <code class="highlighter-rouge">resync</code> is only executed during initial ingestion or if the Delphix user manually starts one. The customer can manually trigger a <code class="highlighter-rouge">resync</code> via the UI by selecting the dSource, going to more options and selecting <strong>Resynchronize dSource</strong>. <img src="/Building_Your_First_Plugin/images/Resync.png" alt="Screenshot" /></p>

<p>!!! tip “Gotcha”
    Although it is not common, it is entirely possible that the staging environment is the same as the source environment. Be careful not to assume otherwise in your plugins.</p>

<h3 id="our-syncing-strategy">Our Syncing Strategy</h3>

<p>For our purposes here in this intro plugin, we will use a simple strategy. We won’t do anything with the resync snapshot parameter and simply copy files from the filesystem on the source environment onto the NFS mount on the staging environment. We will do this by running the Unix tool <code class="highlighter-rouge">rsync</code> from our staging environment, and rely on passwordless SSH to connect to the source environment.</p>

<p>!!! info
    This plugin is assuming that <code class="highlighter-rouge">rsync</code> is installed on the staging host, and that the staging
    host user is able to SSH into the source host without having to type in a password. A more
    full-featured plugin would test these assumptions, usually as part of discovery.</p>

<p>In the special case mentioned above, where the staging environment is the same as the source environment, we could likely do something more efficient. However, for simplicity’s sake, we won’t do that here.</p>

<h2 id="defining-your-linked-source-data-format">Defining Your Linked Source Data Format</h2>

<p>In order to be able to successfully do the copying required, plugins might need to get some information from the end-user of your plugin. In our case, we need to tell <code class="highlighter-rouge">rsync</code> how to access the files. This means we need to know the source environment’s IP address (or domain name), the username we need to connect as, and finally the location where the files live.</p>

<p>Again, we will be using a JSON schema to define the data format. The user will be presented with a UI that lets them provide all the information our schema specifies.</p>

<p>Open up <code class="highlighter-rouge">schema.json</code> in your editor/IDE. Locate the <code class="highlighter-rouge">LinkedSourceDefinition</code> and replace it with the following schema:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"linkedSourceDefinition"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"object"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"additionalProperties"</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w">
    </span><span class="s2">"required"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"sourceAddress"</span><span class="p">,</span><span class="w"> </span><span class="s2">"username"</span><span class="p">,</span><span class="w"> </span><span class="s2">"mountLocation"</span><span class="p">],</span><span class="w">
    </span><span class="s2">"properties"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"sourceAddress"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"prettyName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Host from which to copy"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"IP or FQDN of host from which to copy"</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="s2">"username"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"prettyName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Username on Source Host"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Username for making SSH connection to source host"</span><span class="w">
        </span><span class="p">},</span><span class="w">
        </span><span class="s2">"mountLocation"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
            </span><span class="s2">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"format"</span><span class="p">:</span><span class="w"> </span><span class="s2">"unixpath"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"prettyName"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Mount Location on Staging Host"</span><span class="p">,</span><span class="w">
            </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Where to mount storage onto the staging host while syncing"</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">},</span><span class="w">
</span></code></pre></div></div>

<p>!!! info
    As will be explained later, this schema will be used to generate Python code.
    All names in the autogenerated Python code will use <code class="highlighter-rouge">lower_case_with_underscores</code> as attribute names as per Python variable naming conventions.
    That is, if we were to use <code class="highlighter-rouge">mountLocation</code> as the schema property name, it would be called
    <code class="highlighter-rouge">mount_location</code> in the generated Python code.</p>

<p>With this schema, the user will be required to provide the source username, the source’s IP address, and the staging mount location as part of the linking process.</p>

<h2 id="implementing-syncing-in-your-plugin">Implementing Syncing in Your Plugin</h2>

<p>There are three things we must do to implement syncing. First, we need to tell the Delphix Engine
where to mount storage onto the staging environment. Next we need to actually do the work of copying
data onto that mounted storage. Finally, we need to generate any snapshot-related data.</p>

<h3 id="mount-specification">Mount Specification</h3>

<p>Before syncing can begin, the Delphix Engine needs to mount some storage onto the staging host.
Since different plugins can have different requirements about where exactly this mount lives, it is
up to the plugin to specify this location. As mentioned above, our simple plugin will get this
location from the user.</p>

<p>Open up the <code class="highlighter-rouge">plugin_runner.py</code> file and find the <code class="highlighter-rouge">linked_mount_specification</code> function (which was generated by <code class="highlighter-rouge">dvp init</code>). Replace it with the following code:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@plugin.linked.mount_specification()
def linked_mount_specification(staged_source, repository):
    mount_location = staged_source.parameters.mount_location
    mount = Mount(staged_source.staged_connection.environment, mount_location)
    return MountSpecification([mount])
</code></pre></div></div>

<p>Let’s take this line-by-line to see what’s going on here.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@plugin.linked.mount_specification()
</code></pre></div></div>
<p>This <a href="/References/Glossary.md#password-property">decorator</a> announces that the following function
is the code that handles the <code class="highlighter-rouge">mount_specification</code> operation. This is what allows the Delphix
Engine to know which function to call when it’s time to learn where to mount. Every operation
definition will begin with a similar decorator.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def linked_mount_specification(staged_source, repository):
</code></pre></div></div>
<p>This begins a Python function definition. We chose to call it <code class="highlighter-rouge">linked_mount_specification</code>, but we
could have chosen any name at all. This function accepts two arguments, one giving information about
the linked source, and one giving information about the associated repository.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    mount_location = staged_source.parameters.mount_location
</code></pre></div></div>

<p>The <code class="highlighter-rouge">staged_source</code> input argument contains an attribute called <code class="highlighter-rouge">parameters</code>. This in turn contains
all of the properties defined by the <code class="highlighter-rouge">linkedSourceDefinition</code> schema. So, in our case, that means
it will contain attributes called <code class="highlighter-rouge">source_address</code>, <code class="highlighter-rouge">username</code>, and <code class="highlighter-rouge">mount_location</code>. Note how any attribute defined in <code class="highlighter-rouge">camelCase</code> in the schema is converted to <code class="highlighter-rouge">variable_with_underscores</code>. This line
simply retrieves the user-provided mount location and saves it in a local variable.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    mount = Mount(staged_source.staged_connection.environment, mount_location)
</code></pre></div></div>

<p>This line constructs a new object from the <a href="/References/Classes.md#mount">Mount class</a>. This class
holds details about how Delphix Engine storage is mounted onto remote environments. Here, we
create a mount object that says to mount onto the staging environment, at the location specified
by the user.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    return MountSpecification([mount])
</code></pre></div></div>

<p>On the line just before this one, we created an object that describes a <em>single</em> mount. Now, we
must return a full <a href="/References/Glossary.md#mount-specification">mount specification</a>. In general,
a mount specification is a collection of mounts. But, in our case, we just have one single mount.
Therefore, we use an array with only one item it in – namely, the one single mount object we
created just above.</p>

<h3 id="data-copying">Data Copying</h3>

<p>As explained <a href="/References/Workflows.md#linked-source-sync">here</a>, the Delphix Engine will always run the plugin’s <code class="highlighter-rouge">preSnapshot</code> operation just before taking a snapshot of the dsource. That means our <code class="highlighter-rouge">preSnapshot</code> operation has to get the NFS share into the desired state. For us, that means that’s the time to do our data copy.</p>

<p>Unlike the previous operations we’ve seen so far, the pre-snapshot operation will not be autogenerated by <code class="highlighter-rouge">dvp init</code>.
So, we will need to add one ourselves.  Open up the <code class="highlighter-rouge">plugin_runner.py</code> file.</p>

<p>First, we’ll add a new import line near the top of the file, so that we can use Delphix’s platform libraries (explained below).</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">dlpx.virtualization</span> <span class="kn">import</span> <span class="n">libs</span>
</code></pre></div></div>

<p>Next, we’ll add a new function:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@plugin.linked.pre_snapshot</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">copy_data_from_source</span><span class="p">(</span><span class="n">staged_source</span><span class="p">,</span> <span class="n">repository</span><span class="p">,</span> <span class="n">source_config</span><span class="p">,</span> <span class="n">snapshot_parameters</span><span class="p">):</span>
    <span class="n">stage_mount_path</span> <span class="o">=</span> <span class="n">staged_source</span><span class="o">.</span><span class="n">mount</span><span class="o">.</span><span class="n">mount_path</span>
    <span class="n">data_location</span> <span class="o">=</span> <span class="s">"{}@{}:{}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">staged_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
        <span class="n">staged_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">source_address</span><span class="p">,</span>
        <span class="n">source_config</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

    <span class="n">rsync_command</span> <span class="o">=</span> <span class="s">"rsync -r {} {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_location</span><span class="p">,</span> <span class="n">stage_mount_path</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">libs</span><span class="o">.</span><span class="n">run_bash</span><span class="p">(</span><span class="n">staged_source</span><span class="o">.</span><span class="n">staged_connection</span><span class="p">,</span> <span class="n">rsync_command</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">exit_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">RuntimeError</span><span class="p">(</span><span class="s">"Could not copy files. Please ensure that passwordless SSH works for {}.</span><span class="se">\n</span><span class="s">{}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">staged_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">source_address</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>
</code></pre></div></div>

<p>Let’s walk through this function and see what’s going on</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">stage_mount_path</span> <span class="o">=</span> <span class="n">staged_source</span><span class="o">.</span><span class="n">mount</span><span class="o">.</span><span class="n">mount_path</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">staged_source</code> argument contains information about the current mount location. Here we save that
to a local variable for convenience.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">data_location</span> <span class="o">=</span> <span class="s">"{}@{}:{}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">staged_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">username</span><span class="p">,</span>
        <span class="n">staged_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">source_address</span><span class="p">,</span>
        <span class="n">source_config</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
</code></pre></div></div>

<p>This code creates a Python string that represents the location of the data that we want to ingest.
This is in the form <code class="highlighter-rouge">&lt;user&gt;@&lt;host&gt;:&lt;path&gt;</code>. For example <code class="highlighter-rouge">jdoe@sourcehost.mycompany.com:/bin</code>. As
before with <code class="highlighter-rouge">mountLocation</code>, we have defined our schemas such that these three pieces of information
were provided by the user. Here we’re just putting them into a format that <code class="highlighter-rouge">rsync</code> will understand.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">rsync_command</span> <span class="o">=</span> <span class="s">"rsync -r {} {}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data_location</span><span class="p">,</span> <span class="n">stage_mount_path</span><span class="p">)</span>
</code></pre></div></div>

<p>This line is the actual Bash command that we’ll be running on the staging host. This will look something like <code class="highlighter-rouge">rsync -r user@host:/source/path /staging/mount/path</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">result</span> <span class="o">=</span> <span class="n">libs</span><span class="o">.</span><span class="n">run_bash</span><span class="p">(</span><span class="n">staged_source</span><span class="o">.</span><span class="n">staged_connection</span><span class="p">,</span> <span class="n">rsync_command</span><span class="p">)</span>
</code></pre></div></div>

<p>This is an example of a <a href="/References/Glossary.md#platform-libraries">platform library</a> function, where we ask the Virtualization Platform
to do some work on our behalf. In this case, we’re asking the platform to run our Bash command on the
staging environment. For full details on the <code class="highlighter-rouge">run_bash</code> platform library function and others, see this <a href="/References/Platform_Libraries.md">reference</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">exit_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">RuntimeError</span><span class="p">(</span><span class="s">"Could not copy files. Please ensure that passwordless SSH works for {}.</span><span class="se">\n</span><span class="s">{}"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">staged_source</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">source_address</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">stderr</span><span class="p">))</span>
</code></pre></div></div>
<p>Finally, we check to see if our Bash command actually worked okay. If not, we raise an error
message, and describe one possible problem for the user to investigate.</p>

<h3 id="saving-snapshot-data">Saving Snapshot Data</h3>

<p>Whenever the Delphix Engine takes a <a href="/References/Glossary.md#snapshot">snapshot</a> of a dSource or VDB,
the plugin has the chance to save any information it likes alongside that snapshot. Later, if the
snapshot is ever used to provision a new VDB, the plugin can use the previously-saved information
to help get the new VDB ready for use.</p>

<p>The format of this data is controlled by the plugin’s <code class="highlighter-rouge">snapshotDefinition</code> schema. In our case, we
don’t have any data we need to save. So, there’s not much to do here. We will not modify the blank
schema that was created by <code class="highlighter-rouge">dvp init</code>.</p>

<p>We do still need to provide python function for the engine to call, but we don’t have to do much.
In fact, the default implementation that was generated by <code class="highlighter-rouge">dvp init</code> will work just fine for our purposes:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@plugin.linked.post_snapshot</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">linked_post_snapshot</span><span class="p">(</span><span class="n">staged_source</span><span class="p">,</span>
                         <span class="n">repository</span><span class="p">,</span>
                         <span class="n">source_config</span><span class="p">,</span>
                         <span class="n">snapshot_parameters</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">SnapshotDefinition</span><span class="p">()</span>
</code></pre></div></div>

<p>The only thing this code is doing is creating a new object using our (empty) snapshot
definition, and returning that new empty object.</p>

<h2 id="how-to-link-and-sync-in-the-delphix-engine">How to Link and Sync in the Delphix Engine</h2>

<p>Let’s try it out and make sure this works!</p>

<p><strong>Prerequisites</strong></p>

<ul>
  <li>
    <p>You should already have a repository and source config set up from the previous page.</p>
  </li>
  <li>
    <p>You can optionally set up a new staging environment. Or, you can simply re-use your source
environment for staging.</p>
  </li>
</ul>

<p><strong>Procedure</strong></p>

<p>!!! note
    Recall that, for simplicity’s sake, this plugin requires that passwordless SSH is set up between
    your staging and source environments. You may want to verify this before continuing.</p>

<ol>
  <li>
    <p>As before, use <code class="highlighter-rouge">dvp build</code> and <code class="highlighter-rouge">dvp upload</code> to get your latest plugin changes installed onto
the Delphix Engine.</p>
  </li>
  <li>
    <p>Go to <strong>Manage &gt; Environments</strong>, select your <strong>source</strong> environment, and then go to the <strong>Databases</strong> tab. Find <strong>Repository for our First Plugin</strong>, and your source config underneath it.</p>
  </li>
  <li>
    <p>From your source config click <strong>Add dSource</strong>. This will begin the linking process. The first
screen you see should ask for the properties that you recently added to your <code class="highlighter-rouge">linkedSourceDefinition</code>. <img src="/Building_Your_First_Plugin/images/LinkingWizard.png" alt="Screenshot" /></p>
  </li>
  <li>
    <p>Walk through the remainder of the screens and hit <strong>Submit</strong>. This will kick off the initial link and first sync.</p>
  </li>
  <li>
    <p>You can confirm that your new dSource was added successfully by going to <strong>Manage &gt; Datasets</strong>.</p>
  </li>
</ol>

<p>After you have finished entering this information, the initial sync process will begin. This is what will call your pre-snapshot operation, thus copying data.</p>

<p>!!! warning “Gotcha”
    Manually creating a dSource sets your plugin’s linked source schema in stone, and you will have to recreate the dSource in order to modify your schema. We will cover how to deal with this correctly later, in the upgrade section. For now, if you need to change your plugin’s linked source schema, you will have to first delete any dSources you have manually added.</p>

<p>!!! question “<a href="https://forms.gle/mi7y1Yafz8H3Gq2P9">Survey</a>”
    Please fill out this <a href="https://forms.gle/mi7y1Yafz8H3Gq2P9">survey</a> to give us feedback about this section.</p>


      
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js" integrity="sha256-lZaRhKri35AyJSypXXs4o6OPFTbTmUoltBbDCbdzegg=" crossorigin="anonymous"></script>
    <script>anchors.add();</script>
    
  </body>
</html>
